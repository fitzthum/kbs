// Copyright (c) 2023 Alibaba Cloud
//
// SPDX-License-Identifier: Apache-2.0
//

use anyhow::*;

//use ear::{Algorithm, Appraisal, Ear, Extensions, VerifierID};
use ear::{Algorithm, Appraisal, Ear, VerifierID};
use openssl::ec::{EcGroup, EcKey};
use openssl::nid::Nid;
use openssl::pkey::PKey;
use serde::Deserialize;
use std::collections::BTreeMap;

const DEFAULT_TOKEN_DURATION: i64 = 5;
const DEFAULT_PROFILE: &str = "tag:github.com,2024:confidential-containers/Trustee";
const DEFAULT_DEVELOPER_NAME: &str = "https://confidentialcontainers.org";

pub struct AttestationTokenBroker {
    config: AttestationTokenConfig,
    private_key_bytes: Vec<u8>,
}

impl AttestationTokenBroker {
    pub fn new(config: AttestationTokenConfig) -> Result<Self> {
        let private_key_bytes = match config.clone().signer {
            Some(signer) => std::fs::read(signer.key_path)?,
            None => generate_ec_keys()?.0,
        };

        Ok(Self {
            config,
            private_key_bytes,
        })
    }

    pub fn issue_ear(&self, submods: BTreeMap<String, Appraisal>) -> Result<String> {
        let now = time::OffsetDateTime::now_utc();

        let ear = Ear {
            profile: self.config.profile_name.clone(),
            iat: now.unix_timestamp(),
            vid: VerifierID {
                build: self.config.build_name.clone(),
                developer: self.config.developer_name.clone(),
            },
            raw_evidence: None,
            nonce: None,
            submods,
            //extensions: Extensions::new(),
        };

        let signed_ear = ear.sign_jwt_pem(Algorithm::ES256, &self.private_key_bytes)?;

        Ok(signed_ear)
    }
}

fn generate_ec_keys() -> Result<(Vec<u8>, Vec<u8>)> {
    let group = EcGroup::from_curve_name(Nid::X9_62_PRIME256V1)?;
    let ec_key = EcKey::generate(&group)?;
    let pkey = PKey::from_ec_key(ec_key)?;

    Ok((pkey.private_key_to_pem_pkcs8()?, pkey.public_key_to_pem()?))
}

/// Configuration for the EAR Token generated by the Attestation Service
#[derive(Deserialize, Debug, Clone)]
pub struct AttestationTokenConfig {
    /// The Attestation Results Token duration time (in minutes)
    /// Default: 5 minutes
    #[serde(default = "default_duration")]
    pub duration_min: i64,

    /// The developer name to be used as part of the Verifier ID
    /// in the EAR.
    /// Default: `https://confidentialcontainers.org`
    #[serde(default = "default_developer")]
    pub developer_name: String,

    /// The build name to be used as part of the Verifier ID
    /// in the EAR.
    /// The default value will be generated from the Cargo package
    /// name and version of the AS.
    #[serde(default = "default_build")]
    pub build_name: String,

    /// The Profile that describes the EAR token
    /// Default: `tag:github.com,2024:confidential-containers/Trustee`
    #[serde(default = "default_profile")]
    pub profile_name: String,

    /// Configuration for signing the EAR
    /// If this is not specified, the EAR
    /// will be signed with an ephemeral private key.
    pub signer: Option<TokenSignerConfig>,
}

fn default_duration() -> i64 {
    DEFAULT_TOKEN_DURATION
}

fn default_developer() -> String {
    DEFAULT_DEVELOPER_NAME.to_string()
}

fn default_profile() -> String {
    DEFAULT_PROFILE.to_string()
}

fn default_build() -> String {
    format!("{} {}", env!("CARGO_PKG_NAME"), env!("CARGO_PKG_VERSION"))
}

#[derive(Deserialize, Debug, Clone)]
pub struct TokenSignerConfig {
    /// Private key that will be used to sign the EAR token
    pub key_path: String,
    pub cert_url: Option<String>,

    // PEM format certificate chain.
    pub cert_path: Option<String>,
}

impl Default for AttestationTokenConfig {
    fn default() -> Self {
        Self {
            duration_min: default_duration(),
            developer_name: default_developer(),
            build_name: default_build(),
            profile_name: default_profile(),
            signer: None,
        }
    }
}

#[cfg(test)]
mod tests {
    use jsonwebtoken::DecodingKey;
    use std::collections::BTreeMap;
    use std::io::Write;
    use tempfile::NamedTempFile;

    use super::*;

    #[test]
    fn test_issue_ear_ephemeral_key() {
        let mut submods = BTreeMap::new();
        submods.insert("cpu".to_string(), ear::Appraisal::new());

        // use default config with no signer.
        // this will sign the token with an ephemeral key.
        let config = AttestationTokenConfig::default();
        let broker = AttestationTokenBroker::new(config).unwrap();

        let _token = broker.issue_ear(submods).unwrap();
    }

    #[test]
    fn test_issue_and_validate_ear() {
        let mut submods = BTreeMap::new();
        submods.insert("cpu".to_string(), ear::Appraisal::new());

        let (private_key_bytes, public_key_bytes) = generate_ec_keys().unwrap();

        let mut private_key_file = NamedTempFile::new().unwrap();
        private_key_file.write_all(&private_key_bytes).unwrap();

        let signer = TokenSignerConfig {
            key_path: private_key_file.path().to_str().unwrap().to_string(),
            cert_url: None,
            cert_path: None,
        };

        let mut config = AttestationTokenConfig::default();
        config.signer = Some(signer);

        let broker = AttestationTokenBroker::new(config).unwrap();
        let token = broker.issue_ear(submods).unwrap();

        let public_key = DecodingKey::from_ec_pem(&public_key_bytes).unwrap();

        let ear = Ear::from_jwt(&token, jsonwebtoken::Algorithm::ES256, &public_key).unwrap();
        ear.validate().unwrap();
    }
}
